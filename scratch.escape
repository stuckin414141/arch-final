Seq
  Seq
    Seq
      Seq
        Nothing
        LetStmt make_adder0
          type: ({x: int, y: int})->((int)->(int))
          Expr
            Ftmlk
            Requires env: false
              Args
                p0 : {x: int, y: int}
                  Ref: true
              Body
                Ftmlk
                Requires env: true
                  Args
                    z0 : int
                      Ref: false
                  Body
                    BinOp +
                      Left
                        BinOp +
                          Left
                            MemberOf 
                              Expr
                                Var p0
                              Type: {x: int, y: int}
                                Field: x
                          Right
                            MemberOf 
                              Expr
                                Var p0
                              Type: {x: int, y: int}
                                Field: y
                          Type: int
                      Right
                        Var z0
                      Type: int
          Is closure: false
          Is recursive: false
      LetStmt point0
        type: {x: int, y: int}
        Expr
          RecordExp
            Field x
              Expr
                Num 5
              Type: int
            Field y
              Expr
                Num 10
              Type: int
        Is closure: false
        Is recursive: false
    LetStmt adder0
      type: (int)->(int)
      Expr
        FtmlkApp
        Type: (int)->(int)
          Func
            Var make_adder0
          Args
            Var point0
      Is closure: false
      Is recursive: false
  Print
    FtmlkApp
    Type: int
      Func
        Var adder0
      Args
        Num 15
